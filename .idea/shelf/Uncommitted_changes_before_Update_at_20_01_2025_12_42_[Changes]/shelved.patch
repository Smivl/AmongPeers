Index: src/main/java/Game/GameMap/GameMap.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Game.GameMap;\r\n\r\nimport Game.GameCharacter.CharacterView;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\nimport Game.Interactables.Interactable;\r\nimport Game.Interactables.Meeting;\r\nimport Game.Interactables.Task.UploadTask;\r\nimport Game.Interactables.Vent;\r\nimport javafx.geometry.Bounds;\r\nimport javafx.scene.Scene;\r\nimport javafx.scene.image.Image;\r\nimport javafx.scene.image.ImageView;\r\nimport javafx.scene.paint.Color;\r\nimport javafx.scene.shape.Ellipse;\r\nimport javafx.scene.shape.Rectangle;\r\nimport javafx.scene.shape.Shape;\r\nimport org.jspace.Tuple;\r\n\r\n\r\npublic class GameMap {\r\n\r\n    private final GameMapView view;\r\n\r\n    private final List<Shape> collisionShapes = new ArrayList<>() {};\r\n    private final Map<Shape, Interactable> ventShapes = new HashMap<>(){};\r\n    private final Map<Shape, Interactable> interactableShapes = new HashMap<>(){};\r\n\r\n    private final List<ImageView> bodies = new ArrayList<>();\r\n\r\n    public GameMapView getView() { return this.view; }\r\n\r\n    public GameMap(Scene scene) {\r\n        this.view = new GameMapView(scene);\r\n\r\n        // Map interactables and vents\r\n        {\r\n            createInteractableCircle(4847, 1263, 264, 206, new Meeting());\r\n\r\n            // Upload\r\n            //    - Lights, Admin, Shields, Weaponry, Caf, Nav\r\n            createInteractableRectangle(3215,2691, 68, 56, 0, new UploadTask());\r\n            createInteractableRectangle(5420,2505, 68, 56, 0, new UploadTask());\r\n            createInteractableRectangle(5669,3891, 68, 56, 0, new UploadTask());\r\n            createInteractableRectangle(6529,670, 68, 56, 0, new UploadTask());\r\n            createInteractableRectangle(5595,498, 68, 56, 45, new UploadTask());\r\n            createInteractableRectangle(8032,1822, 68, 56, 0, new UploadTask());\r\n\r\n            // Vents\r\n            createInteractableRectangle(5720, 1429, 99, 74, 0, new Vent());\r\n            createInteractableRectangle(6542, 781, 99, 74, 0, new Vent());\r\n            createInteractableRectangle(7838, 1951, 99, 74, 0, new Vent());\r\n            createInteractableRectangle(7838, 2529, 99, 74, 0, new Vent());\r\n            createInteractableRectangle(6644, 2536, 99, 74, 0, new Vent());\r\n            createInteractableRectangle(6669, 3960, 99, 74, 0, new Vent());\r\n            createInteractableRectangle(5411, 3169, 99, 74, 0, new Vent());\r\n            createInteractableRectangle(3043, 2131, 99, 74, 0, new Vent());\r\n            createInteractableRectangle(2697, 2630, 99, 74, 0, new Vent());\r\n            createInteractableRectangle(2201, 925, 99, 74, 0, new Vent());\r\n            createInteractableRectangle(1015, 1929, 99, 74, 0, new Vent());\r\n            createInteractableRectangle(1211, 2630, 99, 74, 0, new Vent());\r\n            createInteractableRectangle(2209, 3837, 99, 74, 0, new Vent());\r\n            createInteractableRectangle(3193, 2824, 99, 74, 0, new Vent());\r\n        }\r\n\r\n        this.view.getChildren().addAll(interactableShapes.keySet());\r\n        this.view.getChildren().addAll(ventShapes.keySet());\r\n\r\n        // Map collision\r\n        {\r\n            // Cafeteria to Upper engine walls\r\n            this.createCollisionRectangle(2327, 537, 1553, 495, 0);\r\n\r\n            // Med bay walls\r\n            this.createCollisionRectangle(3482, 1335, 281, 158, 0);\r\n\r\n            //\r\n            this.createCollisionRectangle(5553, 2492, 559, 85, 0);\r\n\r\n            // Cafeteria walls\r\n            this.createCollisionRectangle(3793, 341, 520, 50, -45);\r\n            this.createCollisionRectangle(4217, 170, 1175, 60, 0);\r\n            this.createCollisionRectangle(5251, 427, 780, 50, 45);\r\n            this.createCollisionRectangle(5889, 697, 496, 340, 0);\r\n            this.createCollisionRectangle(3756, 1335, 132, 592, 0);\r\n            this.createCollisionRectangle(3700, 1976, 694, 216, 45);\r\n            this.createCollisionRectangle(4070, 2213, 675, 730, 0);\r\n            this.createCollisionRectangle(4998, 2212, 1574, 305, 0);\r\n            this.createCollisionRectangle(5389, 1945, 690, 148, -45);\r\n            this.createCollisionRectangle(5902, 1345, 680, 500, 0);\r\n\r\n            // Cafeteria tables\r\n            this.createCollisionCircle(4850, 1258, 230, 175);\r\n            this.createCollisionCircle(4394, 779, 232, 167);\r\n            this.createCollisionCircle(4394, 1714, 232, 167);\r\n            this.createCollisionCircle(5288, 769, 225, 168);\r\n            this.createCollisionCircle(5288, 1716, 225, 168);\r\n\r\n            // Weapony walls\r\n            this.createCollisionRectangle(6385, 652, 34, 258, 0);\r\n            this.createCollisionRectangle(6416, 652, 63, 220, 0);\r\n            this.createCollisionRectangle(6379, 594, 385, 47, 0);\r\n\r\n            this.createCollisionCircle(6668, 1103, 55, 50);\r\n        }\r\n\r\n        this.view.getChildren().addAll(this.collisionShapes);\r\n    }\r\n\r\n    public void onUpdate(double delta) {\r\n    }\r\n\r\n    public void addPlayer(CharacterView playerView, boolean isVisible){\r\n        view.getChildren().add(playerView);\r\n        playerView.setVisible(isVisible);\r\n\r\n    }\r\n\r\n    public void onReset() {\r\n        this.view.getChildren().removeAll(bodies);\r\n        bodies.clear();\r\n    }\r\n\r\n    public void onPlayerKilled(double[] position) {\r\n        Image i = new Image(\"dead1.png\");\r\n        ImageView newBody = new ImageView(i);\r\n\r\n        newBody.setLayoutX(position[0] - (i.getWidth()/2));\r\n        newBody.setLayoutY(position[1] - (i.getHeight()/4));\r\n\r\n        bodies.add(newBody);\r\n\r\n        newBody.setViewOrder(-position[1]);\r\n\r\n        this.view.onPlayerKilled(newBody);\r\n    }\r\n\r\n    public boolean checkCollisionWithBodies(CharacterView characterView){\r\n        for (ImageView body : bodies){\r\n            double centreX = body.getLayoutX() + 50;\r\n            double centreY = body.getLayoutY() + 25;\r\n\r\n            double dist = Math.sqrt(Math.pow(characterView.getCenterX()-centreX, 2)+Math.pow(characterView.getCenterY()-centreY, 2));\r\n            if(dist < 150) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public Interactable getInteractable(CharacterView characterView){\r\n        return checkInteractableCollision(characterView, interactableShapes);\r\n    }\r\n\r\n    public Interactable getVent(CharacterView characterView){\r\n        return checkInteractableCollision(characterView, ventShapes);\r\n    }\r\n\r\n    private Interactable checkInteractableCollision(CharacterView characterView, Map<Shape, Interactable> ventShapes) {\r\n        Bounds playerBounds = characterView.getBoundsInParent();\r\n        Rectangle playerShape = new Rectangle(playerBounds.getMinX(), playerBounds.getMinY(), playerBounds.getWidth(), playerBounds.getHeight());\r\n        this.view.getChildren().add(playerShape);\r\n\r\n        for (Map.Entry<Shape, Interactable> entry : ventShapes.entrySet()){\r\n            Shape intersection = Shape.intersect(playerShape, entry.getKey());\r\n            if(!intersection.getBoundsInLocal().isEmpty()){\r\n                this.view.getChildren().remove(playerShape);\r\n                return entry.getValue();\r\n            }\r\n        }\r\n\r\n        this.view.getChildren().remove(playerShape);\r\n        return null;\r\n    }\r\n\r\n    public boolean checkCollision(CharacterView characterView) {\r\n        Bounds playerBounds = characterView.getBoundsInParent();\r\n        Rectangle playerShape = new Rectangle(playerBounds.getMinX(), playerBounds.getMinY(), playerBounds.getWidth(), playerBounds.getHeight());\r\n        this.view.getChildren().add(playerShape);\r\n\r\n        for (Shape shape : collisionShapes){\r\n            Shape intersection = Shape.intersect(playerShape, shape);\r\n            if(!intersection.getBoundsInLocal().isEmpty()){\r\n                this.view.getChildren().remove(playerShape);\r\n                return true;\r\n            }\r\n        }\r\n\r\n        this.view.getChildren().remove(playerShape);\r\n        return false;\r\n    }\r\n\r\n    private void createCollisionRectangle(int x, int y, int width, int height, int angle) {\r\n\r\n        Rectangle wall = new Rectangle(x, y, width, height);\r\n        wall.setRotate(angle);\r\n        wall.setFill(Color.TRANSPARENT);\r\n        wall.setStroke(Color.RED);\r\n        this.collisionShapes.add(wall);\r\n    }\r\n\r\n    private void createCollisionCircle(int x, int y, int radiusX, int radiusY) {\r\n\r\n        Ellipse ellipse = new Ellipse(x, y, radiusX, radiusY);\r\n        ellipse.setFill(Color.TRANSPARENT);\r\n        ellipse.setStroke(Color.RED);\r\n        this.collisionShapes.add(ellipse);\r\n\r\n    }\r\n\r\n    private <I extends Interactable> void createInteractableRectangle(int x, int y, int width, int height, int angle, I interactable) {\r\n        Rectangle rect = new Rectangle(x, y, width, height);\r\n        rect.setRotate(angle);\r\n        rect.setFill(Color.TRANSPARENT);\r\n        rect.setStroke(Color.BLUE); // debugging\r\n\r\n        if(interactable instanceof Vent) this.ventShapes.put(rect, interactable);\r\n        else this.interactableShapes.put(rect, interactable);\r\n    }\r\n\r\n    private <I extends Interactable> void createInteractableCircle(int x, int y, int radiusX, int radiusY, I interactable) {\r\n\r\n        Ellipse ellipse = new Ellipse(x, y, radiusX, radiusY);\r\n        ellipse.setFill(Color.TRANSPARENT);\r\n        ellipse.setStroke(Color.BLUE);\r\n\r\n        this.interactableShapes.put(ellipse, interactable);\r\n\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/Game/GameMap/GameMap.java b/src/main/java/Game/GameMap/GameMap.java
--- a/src/main/java/Game/GameMap/GameMap.java	(revision 78b6d1e85c33d63aaff86e6bb72ba2c4f6fc9865)
+++ b/src/main/java/Game/GameMap/GameMap.java	(date 1737373259220)
@@ -120,6 +120,10 @@
 
     }
 
+    public void removePlayer(CharacterView characterView) {
+        view.getChildren().remove(characterView);
+    }
+
     public void onReset() {
         this.view.getChildren().removeAll(bodies);
         bodies.clear();
@@ -232,5 +236,4 @@
         this.interactableShapes.put(ellipse, interactable);
 
     }
-
 }
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"0da40e2d-179e-4870-afcb-4409baa8c408\" name=\"Changes\" comment=\"Input lock, resets, and server bug fix\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/Game/GameController.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/Game/GameController.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/Game/GameMap/GameMap.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/Game/GameMap/GameMap.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/Main.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/Main.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/Menu/JoinMenu.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/Menu/JoinMenu.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/Menu/MenuManager.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/Menu/MenuManager.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/Server/Server.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/Server/Server.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/Server/ServerBroadcast.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/Server/ServerBroadcast.java\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;customColor&quot;: &quot;&quot;,\r\n  &quot;associatedIndex&quot;: 2\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2ro6dIlMDizVZrF96WVBsIb3QWS\" />\r\n  <component name=\"ProjectLevelVcsManager\">\r\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\r\n  </component>\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;ASKED_ADD_EXTERNAL_FILES&quot;: &quot;true&quot;,\r\n    &quot;Application.BroadcastFinder.executor&quot;: &quot;Run&quot;,\r\n    &quot;Application.ServerBroadcast.executor&quot;: &quot;Run&quot;,\r\n    &quot;Application.testingServer.executor&quot;: &quot;Run&quot;,\r\n    &quot;Application.testingServer2.executor&quot;: &quot;Run&quot;,\r\n    &quot;Maven.amongpeers [org.openjfx:javafx-maven-plugin:0.0.6:run].executor&quot;: &quot;Run&quot;,\r\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;master&quot;,\r\n    &quot;kotlin-language-version-configured&quot;: &quot;true&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;D:/projects&quot;,\r\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,\r\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"CopyClassDialog.RECENTS_KEY\">\r\n      <recent name=\"\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"RunManager\" selected=\"Application.ServerBroadcast\">\r\n    <configuration name=\"BroadcastFinder\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"Server.BroadcastFinder\" />\r\n      <module name=\"amongpeers\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"Server.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"ServerBroadcast\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"Server.ServerBroadcast\" />\r\n      <module name=\"amongpeers\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"Server.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"testingServer\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"testingServer\" />\r\n      <module name=\"amongpeers\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"testingServer2\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"testingServer2\" />\r\n      <module name=\"amongpeers\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Application.ServerBroadcast\" />\r\n        <item itemvalue=\"Application.BroadcastFinder\" />\r\n        <item itemvalue=\"Application.testingServer\" />\r\n        <item itemvalue=\"Application.testingServer2\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"jdk-21.0.2-openjdk-21.0.2-4caba194b151-4f524021\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"0da40e2d-179e-4870-afcb-4409baa8c408\" name=\"Changes\" comment=\"\" />\r\n      <created>1737213167568</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1737213167568</updated>\r\n      <workItem from=\"1737213169402\" duration=\"6670000\" />\r\n      <workItem from=\"1737308782323\" duration=\"11848000\" />\r\n      <workItem from=\"1737360593474\" duration=\"10072000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"Game hosting and joining through LAN.\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1737315774572</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1737315774572</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"Input lock, resets, and server bug fix\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1737366266725</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1737366266725</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"3\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <option name=\"ADD_EXTERNAL_FILES_SILENTLY\" value=\"true\" />\r\n    <MESSAGE value=\"Game hosting and joining through LAN.\" />\r\n    <MESSAGE value=\"Input lock, resets, and server bug fix\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Input lock, resets, and server bug fix\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 78b6d1e85c33d63aaff86e6bb72ba2c4f6fc9865)
+++ b/.idea/workspace.xml	(date 1737373259267)
@@ -4,15 +4,12 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="0da40e2d-179e-4870-afcb-4409baa8c408" name="Changes" comment="Input lock, resets, and server bug fix">
+    <list default="true" id="0da40e2d-179e-4870-afcb-4409baa8c408" name="Changes" comment="updated server join">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/main/java/Game/GameController.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/Game/GameController.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/main/java/Game/GameMap/GameMap.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/Game/GameMap/GameMap.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/Main.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/Main.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/Menu/JoinMenu.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/Menu/JoinMenu.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/main/java/Menu/MenuManager.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/Menu/MenuManager.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/main/java/Server/Server.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/Server/Server.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/Server/ServerBroadcast.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/Server/ServerBroadcast.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -137,7 +134,7 @@
       <updated>1737213167568</updated>
       <workItem from="1737213169402" duration="6670000" />
       <workItem from="1737308782323" duration="11848000" />
-      <workItem from="1737360593474" duration="10072000" />
+      <workItem from="1737360593474" duration="12164000" />
     </task>
     <task id="LOCAL-00001" summary="Game hosting and joining through LAN.">
       <option name="closed" value="true" />
@@ -155,7 +152,15 @@
       <option name="project" value="LOCAL" />
       <updated>1737366266725</updated>
     </task>
-    <option name="localTasksCounter" value="3" />
+    <task id="LOCAL-00003" summary="updated server join">
+      <option name="closed" value="true" />
+      <created>1737371500374</created>
+      <option name="number" value="00003" />
+      <option name="presentableId" value="LOCAL-00003" />
+      <option name="project" value="LOCAL" />
+      <updated>1737371500374</updated>
+    </task>
+    <option name="localTasksCounter" value="4" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -165,6 +170,7 @@
     <option name="ADD_EXTERNAL_FILES_SILENTLY" value="true" />
     <MESSAGE value="Game hosting and joining through LAN." />
     <MESSAGE value="Input lock, resets, and server bug fix" />
-    <option name="LAST_COMMIT_MESSAGE" value="Input lock, resets, and server bug fix" />
+    <MESSAGE value="updated server join" />
+    <option name="LAST_COMMIT_MESSAGE" value="updated server join" />
   </component>
 </project>
\ No newline at end of file
Index: src/main/java/Game/GameController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Game;\r\n\r\nimport Game.GameCharacter.CharacterView;\r\nimport Game.GameMap.GameMap;\r\nimport Game.Player.Player;\r\nimport Game.Player.PlayerInfo;\r\nimport Game.Meeting.MeetingView;\r\nimport Server.ClientUpdate;\r\nimport Server.Request;\r\nimport Server.Response;\r\nimport Server.ServerUpdate;\r\nimport javafx.animation.AnimationTimer;\r\nimport javafx.application.Platform;\r\nimport javafx.scene.Scene;\r\nimport javafx.scene.input.KeyEvent;\r\nimport javafx.scene.layout.StackPane;\r\nimport javafx.scene.paint.Color;\r\nimport org.jspace.ActualField;\r\nimport org.jspace.FormalField;\r\nimport org.jspace.RemoteSpace;\r\nimport org.jspace.Space;\r\n\r\nimport java.net.URI;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.Objects;\r\n\r\n\r\npublic class GameController {\r\n\r\n    // game controls\r\n    private final Map<String, CharacterView> otherPlayerViews = new HashMap<>();\r\n    private final String name;\r\n    private Player player;\r\n    private GameMap map;\r\n    private MeetingView meetingView;\r\n    private long previousFrameTime = 0;\r\n\r\n    private Map<String, double[]> spawnPoints = new HashMap<>();\r\n\r\n    // server controls\r\n    private Space serverSpace;\r\n    private Space playerSpace;\r\n    private URI serverURI;\r\n    private Thread serverUpdateThread;\r\n\r\n    public Player getPlayer() {\r\n        return player;\r\n    }\r\n\r\n    public GameController(String name, URI serverURI){\r\n        this.name = name;\r\n        this.serverURI = serverURI;\r\n        try {\r\n            System.out.println(serverURI.getScheme() + \"://\" +\r\n                    serverURI.getHost() + \":\" +\r\n                    serverURI.getPort() + \"/\" +\r\n                    \"server\" + \"?\" +\r\n                    serverURI.getQuery());\r\n            this.serverSpace = new RemoteSpace(\r\n                    serverURI.getScheme() + \"://\" +\r\n                            serverURI.getHost() + \":\" +\r\n                            serverURI.getPort() + \"/\" +\r\n                            \"server\" + \"?\" +\r\n                            serverURI.getQuery());\r\n        } catch (Exception e){\r\n            e.printStackTrace(System.out);\r\n        }\r\n        // player.join();\r\n        // player.init();\r\n    }\r\n\r\n    public Response join() {\r\n        try{\r\n            serverSpace.put(Request.JOIN);\r\n            serverSpace.put(Request.JOIN, name);\r\n\r\n            Object[] response = serverSpace.get(new ActualField(name), new FormalField(Response.class));\r\n\r\n            switch ((Response) response[1]){\r\n                case SUCCESS:\r\n                case ACCEPTED:{\r\n                    playerSpace = new RemoteSpace(\r\n                            serverURI.getScheme() + \"://\" +\r\n                                    serverURI.getHost() + \":\" +\r\n                                    serverURI.getPort() + \"/\" +\r\n                                    name + \"?\" +\r\n                                    serverURI.getQuery()\r\n                    );\r\n                    player = new Player(name, playerSpace);\r\n                    return (Response) response[1];\r\n                }\r\n                case CONFLICT:\r\n                case PERMISSION_DENIED:\r\n                case ERROR:\r\n                case FAILURE:{\r\n                    return (Response) response[1];\r\n                }\r\n            }\r\n\r\n\r\n        }catch (Exception e){\r\n            System.out.println(\"Error in join\");\r\n            System.out.println(e.getMessage());\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public void waitForStart(Scene scene){\r\n        try {\r\n            playerSpace.get(new ActualField(ServerUpdate.GAME_START));\r\n\r\n            System.out.println(\"Game started\");\r\n            player.setInputLocked(false);\r\n\r\n            Platform.runLater(() -> start(scene));\r\n        } catch (Exception e){\r\n            System.out.println(\"Stopped waiting for start!\");\r\n        }\r\n    }\r\n\r\n    private void start(Scene scene) {\r\n        player.init();\r\n\r\n        map = new GameMap(scene);\r\n\r\n        meetingView = new MeetingView(scene);\r\n\r\n        meetingView.addSendMessageFunction(\r\n                message -> {\r\n                    try {\r\n                        playerSpace.put(ClientUpdate.MESSAGE);\r\n                        playerSpace.put(ClientUpdate.MESSAGE, message);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace(System.out);\r\n                    }\r\n                    return null;\r\n                }\r\n        );\r\n\r\n        meetingView.addVoteForFunction(\r\n                playerName -> {\r\n                    try {\r\n                        playerSpace.put(ClientUpdate.VOTE);\r\n                        playerSpace.put(ClientUpdate.VOTE, playerName);\r\n                    } catch (InterruptedException e){\r\n                        e.printStackTrace(System.out);\r\n                    }\r\n                    return null;\r\n                }\r\n        );\r\n\r\n        meetingView.initialize();\r\n\r\n        player.setController(this);\r\n\r\n        // Add player to map and add map to root\r\n        map.getView().getChildren().add(player.getCharacterView());\r\n\r\n\r\n        StackPane root = new StackPane();\r\n        scene.setRoot(root);\r\n        root.getChildren().clear();\r\n        root.getChildren().addAll(map.getView(), player.getPlayerView(), meetingView);\r\n\r\n        player.getPlayerView().prefWidthProperty().bind(root.widthProperty());\r\n        player.getPlayerView().prefHeightProperty().bind(root.heightProperty());\r\n\r\n        scene.addEventFilter(KeyEvent.KEY_PRESSED, this::handleKeyPressed);\r\n        scene.addEventFilter(KeyEvent.KEY_RELEASED, this::handleKeyReleased);\r\n\r\n        serverUpdateThread = new Thread(this::serverUpdates);\r\n        serverUpdateThread.start();\r\n\r\n        AnimationTimer gameLoop = new AnimationTimer() {\r\n\r\n            public void handle(long currentFrameTime) {\r\n                if (previousFrameTime == 0) {\r\n                    previousFrameTime = currentFrameTime;\r\n                } else {\r\n                    long delta_nano = currentFrameTime - previousFrameTime;\r\n                    previousFrameTime = currentFrameTime;\r\n\r\n                    double delta = (double)delta_nano / 1.0E9;\r\n\r\n                    onUpdate(delta);\r\n                }\r\n            }\r\n        };\r\n        gameLoop.start();\r\n    }\r\n\r\n    public void onUpdate(double delta){\r\n\r\n        player.onUpdate(delta, map);\r\n        map.onUpdate(delta);\r\n\r\n        map.getView().render(player.getCharacterView());\r\n\r\n    }\r\n\r\n    // CLIENT SIDE\r\n    private void serverUpdates(){\r\n        while (true){\r\n            try {\r\n                Object[] update = playerSpace.get(new FormalField(ServerUpdate.class));\r\n                switch ((ServerUpdate) update[0]) {\r\n                    case POSITION: {\r\n                        Object[] newPosition = playerSpace.get(new ActualField(ServerUpdate.POSITION), new FormalField(String.class), new FormalField(Object.class), new FormalField(Object.class));\r\n\r\n                        Platform.runLater(() -> handlePositionUpdate((String) newPosition[1], (double[]) newPosition[2], (double[]) newPosition[3]));\r\n                        break;\r\n                    }\r\n                    case PLAYER_JOINED: {\r\n                        Object[] newPlayerObject = playerSpace.get(\r\n                                new ActualField(ServerUpdate.PLAYER_JOINED),\r\n                                new FormalField(String.class),\r\n                                new FormalField(PlayerInfo.class)\r\n                        );\r\n\r\n                        String newPlayerName = (String) newPlayerObject[1];\r\n                        PlayerInfo newPlayerInfo = (PlayerInfo) newPlayerObject[2];\r\n\r\n                        spawnPoints.put(newPlayerName, newPlayerInfo.position);\r\n\r\n                        meetingView.addPlayersInfo(newPlayerName, newPlayerInfo);\r\n                        Platform.runLater(() -> handleJoinedUpdate(newPlayerName, newPlayerInfo));\r\n                        break;\r\n                    }\r\n                    case KILLED: {\r\n                        Object[] killedInfo = playerSpace.get(new ActualField(ServerUpdate.KILLED), new FormalField(String.class));\r\n\r\n                        String playerKilled = (String) killedInfo[1];\r\n\r\n                        // meetingView.killPlayer(playerKilled); TO FIX WHEN PLAYER GETS KILLED\r\n\r\n                        Platform.runLater(() -> handleKilledUpdate(playerKilled));\r\n                        break;\r\n                    }\r\n                    case MEETING_START: {\r\n\r\n                        Object[] caller = playerSpace.get(new ActualField(ServerUpdate.MEETING_START), new FormalField(String.class));\r\n                        String callerName = (String) caller[1];\r\n                        System.out.println(callerName + \" requested chat. Start chatting...\");\r\n                        Platform.runLater(() -> {\r\n                            meetingView.show();\r\n                            resetPlayerPositions();\r\n                        });\r\n\r\n                        player.setInputLocked(true);\r\n                        break;\r\n                    }\r\n                    case MESSAGE: {\r\n                        Object[] message = playerSpace.get(new ActualField(ServerUpdate.MESSAGE), new FormalField(String.class), new FormalField(String.class));\r\n                        Platform.runLater(() -> meetingView.addMessage((String) message[1],(String) message[2], Color.BLUE));\r\n                        break;\r\n                    }\r\n                    case MEETING_DONE: {\r\n                        Platform.runLater(() -> meetingView.hide());\r\n                        Object[] t = playerSpace.get(new ActualField(ServerUpdate.MEETING_DONE), new FormalField(String.class));\r\n\r\n                        if (Objects.equals((String) t[1], \"NO_ELIMINATION\")){\r\n                            System.out.println(\"No one was eliminated\");\r\n                        } else {\r\n                            System.out.println(t[1] + \" was eliminated\");\r\n                            Platform.runLater(() -> handleVotedOffUpdate((String) t[1]));\r\n                        }\r\n\r\n                        // reset players position\r\n                        player.setInputLocked(false);\r\n                        break;\r\n                    }\r\n                    case PLAYER_LEFT: {\r\n                        System.out.println(\"Player left!\");\r\n                        break;\r\n                    }\r\n                    case PLAYER_INIT: {\r\n                        System.out.println(\"ERROR: got PLAYER_INIT after player has been initialized!\");\r\n                        break;\r\n                    }\r\n                    case VOTE: {\r\n                        System.out.println(\"ERROR: vote not implemented yet\");\r\n                        break;\r\n                    }\r\n                    case GAME_START: {\r\n                        player.setInputLocked(false);\r\n                        break;\r\n                    }\r\n                    case SABOTAGE:\r\n                    case TASK_COMPLETE: break;\r\n                }\r\n            }catch (Exception e){\r\n                e.printStackTrace(System.out);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public CharacterView getPlayerToKill(CharacterView killer){\r\n\r\n        CharacterView result = null;\r\n        double min_dist = 0;\r\n\r\n        for(CharacterView player : otherPlayerViews.values()){\r\n\r\n            if (player.getIsImposter() || !player.getIsAlive()) continue;\r\n\r\n            double dist = Math.sqrt(Math.pow(killer.getCenterX()-player.getCenterX(), 2)+Math.pow(killer.getCenterY()-player.getCenterY(), 2));\r\n            if(dist < 100 && (result == null || dist < min_dist)){\r\n                result = player;\r\n                min_dist = dist;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    public void handlePositionUpdate(String playerName, double[] position, double[] velocity){\r\n        CharacterView characterView = otherPlayerViews.get(playerName);\r\n        characterView.render(position, velocity);\r\n    }\r\n\r\n    public void handleVotedOffUpdate(String playerName){\r\n        if(playerName.equals(name)) player.onKilled();\r\n\r\n        for(CharacterView characterView : otherPlayerViews.values()){\r\n            if(characterView.getName().equals(playerName)) characterView.onKilled();\r\n            characterView.setVisible(!player.getInfo().isAlive || characterView.getIsAlive());\r\n        }\r\n    }\r\n\r\n    public void handleKilledUpdate(String playerName){\r\n        if(playerName.equals(name)) {\r\n            player.onKilled();\r\n            map.onPlayerKilled(new double[]{player.getInfo().position[0], player.getInfo().position[1]});\r\n        }\r\n\r\n        for(CharacterView characterView : otherPlayerViews.values()){\r\n            if(characterView.getName().equals(playerName)){\r\n                characterView.onKilled();\r\n                map.onPlayerKilled(new double[]{characterView.getCenterX(), characterView.getCenterY()});\r\n            }\r\n\r\n            characterView.setVisible(!player.getInfo().isAlive || characterView.getIsAlive());\r\n        }\r\n    }\r\n\r\n    public void handleJoinedUpdate(String newPlayerName, PlayerInfo newPlayerInfo){\r\n        PlayerInfo mainPlayerInfo = player.getInfo();\r\n\r\n        CharacterView newPlayer = new CharacterView(\r\n                newPlayerName,\r\n                newPlayerInfo,\r\n                (newPlayerInfo.isImposter && mainPlayerInfo.isImposter) ? Color.RED : Color.WHITE\r\n        );\r\n\r\n        otherPlayerViews.put(newPlayerName, newPlayer);\r\n\r\n        // add player and set visibility\r\n        map.addPlayer(newPlayer, !mainPlayerInfo.isAlive || newPlayer.getIsAlive());\r\n    }\r\n\r\n    public void handleKeyReleased(KeyEvent event) {\r\n        player.handleKeyReleased(event);\r\n    }\r\n\r\n    public void handleKeyPressed(KeyEvent event) {\r\n        player.handleKeyPressed(event);\r\n    }\r\n\r\n    private void resetPlayerPositions(){\r\n        System.out.println(\"reset Pos\");\r\n        player.resetPosition();\r\n        for(String player : otherPlayerViews.keySet()){\r\n            otherPlayerViews.get(player).render(spawnPoints.get(player), new double[]{0,0});\r\n        }\r\n\r\n        // Clear bodies\r\n        map.onReset();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/Game/GameController.java b/src/main/java/Game/GameController.java
--- a/src/main/java/Game/GameController.java	(revision 78b6d1e85c33d63aaff86e6bb72ba2c4f6fc9865)
+++ b/src/main/java/Game/GameController.java	(date 1737373233082)
@@ -106,6 +106,15 @@
         return null;
     }
 
+    public void leave(){
+        try{
+            serverSpace.put(Request.LEAVE);
+            serverSpace.put(Request.LEAVE, name);
+        }catch (Exception e){
+            System.out.println("Error in leave");
+        }
+    }
+
     public void waitForStart(Scene scene){
         try {
             playerSpace.get(new ActualField(ServerUpdate.GAME_START));
@@ -271,7 +280,9 @@
                         break;
                     }
                     case PLAYER_LEFT: {
-                        System.out.println("Player left!");
+                        Object[] playerLeft = playerSpace.get(new ActualField(ServerUpdate.PLAYER_LEFT), new FormalField(String.class));
+
+                        Platform.runLater(() -> handleLeftUpdate((String) playerLeft[1]));
                         break;
                     }
                     case PLAYER_INIT: {
@@ -345,7 +356,7 @@
         }
     }
 
-    public void handleJoinedUpdate(String newPlayerName, PlayerInfo newPlayerInfo){
+    public void handleJoinedUpdate(String newPlayerName, PlayerInfo newPlayerInfo) {
         PlayerInfo mainPlayerInfo = player.getInfo();
 
         CharacterView newPlayer = new CharacterView(
@@ -360,6 +371,11 @@
         map.addPlayer(newPlayer, !mainPlayerInfo.isAlive || newPlayer.getIsAlive());
     }
 
+    public void handleLeftUpdate(String playerName){
+        map.removePlayer(otherPlayerViews.get(playerName));
+        otherPlayerViews.remove(playerName);
+    }
+
     public void handleKeyReleased(KeyEvent event) {
         player.handleKeyReleased(event);
     }
Index: src/main/java/Menu/MenuManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Menu;\r\n\r\nimport Game.GameController;\r\nimport Server.Server;\r\nimport Server.ServerScan;\r\nimport Server.Response;\r\nimport Server.ServerBroadcast;\r\nimport javafx.application.Platform;\r\nimport javafx.scene.Scene;\r\nimport org.jspace.SequentialSpace;\r\nimport org.jspace.Space;\r\n\r\nimport java.net.DatagramPacket;\r\nimport java.net.InetAddress;\r\nimport java.net.URI;\r\nimport java.net.URISyntaxException;\r\nimport java.util.Map;\r\nimport java.util.Objects;\r\n\r\n\r\npublic class MenuManager {\r\n    private final Scene scene;\r\n    private Thread gameWaitingThread;\r\n    private Server server;\r\n    private GameController gameController;\r\n    private MainMenu mainMenu;\r\n    private HostMenu hostMenu;\r\n    private JoinMenu joinMenu;\r\n    private LobbyMenu lobbyMenu;\r\n\r\n    public MenuManager(Scene scene) {\r\n        this.scene = scene;\r\n        initializeMenus();\r\n    }\r\n\r\n    private void initializeMenus() {\r\n        mainMenu = new MainMenu(this);\r\n        hostMenu = new HostMenu(this);\r\n        joinMenu = new JoinMenu(this);\r\n        lobbyMenu = new LobbyMenu(this);\r\n    }\r\n\r\n    public void transitionToMainMenu() {\r\n        if (!Objects.isNull(server)){ // any server created is killed\r\n            ServerBroadcast.stopServer();\r\n            server.shutdown();\r\n            server = null;\r\n        }\r\n        if (!Objects.isNull(gameWaitingThread)){ // if were waiting to start game, abort\r\n            gameWaitingThread.interrupt();\r\n            gameWaitingThread = null;\r\n        }\r\n        scene.setRoot(mainMenu);\r\n    }\r\n\r\n    public void transitionToHostMenu() {\r\n        scene.setRoot(hostMenu);\r\n    }\r\n\r\n    public void transitionToJoinMenu() {\r\n        scene.setRoot(joinMenu);\r\n        joinMenu.hideErrorMessage();\r\n\r\n        new Thread(joinMenu::refreshServers).start();\r\n    }\r\n\r\n    public void transitionToLobbyMenu(boolean isHosting, String name, String IP, int Port) {\r\n        try {\r\n            URI serverURI = new URI(\"tcp://\" + IP.replace(\"/\", \"\") + \":\" + Port + \"/?keep\");\r\n            System.out.println(serverURI);\r\n\r\n            if (isHosting) {\r\n                new Thread(() -> ServerBroadcast.startServer(name)).start();\r\n\r\n                Space serverSpace = new SequentialSpace();\r\n                server = new Server(serverURI, serverSpace);\r\n\r\n                server.start();\r\n            }\r\n\r\n            gameController = new GameController(name, serverURI);\r\n            Response serverResponse = gameController.join();\r\n            System.out.println(\"RAN HERE\");\r\n            if (serverResponse.isSuccesful()){ // always successful for host\r\n                lobbyMenu.setHosting(isHosting);\r\n                scene.setRoot(lobbyMenu);\r\n                gameWaitingThread = new Thread(() ->\r\n                {\r\n                    System.out.println(\"waiting\");\r\n                    gameController.waitForStart(scene);\r\n                });\r\n                gameWaitingThread.start();\r\n            } else { // must be in join menu\r\n                System.out.println(serverResponse);\r\n                joinMenu.displayErrorMessage(serverResponse.getErrorMessage());\r\n            }\r\n        } catch (URISyntaxException e){\r\n            e.printStackTrace(System.out);\r\n            joinMenu.displayErrorMessage(\"Could not parse address\");\r\n        }\r\n    }\r\n\r\n    public void startGame() {\r\n        ServerBroadcast.stopServer();\r\n        server.startGame();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/Menu/MenuManager.java b/src/main/java/Menu/MenuManager.java
--- a/src/main/java/Menu/MenuManager.java	(revision 78b6d1e85c33d63aaff86e6bb72ba2c4f6fc9865)
+++ b/src/main/java/Menu/MenuManager.java	(date 1737372269711)
@@ -41,6 +41,11 @@
     }
 
     public void transitionToMainMenu() {
+        if(!Objects.isNull(gameController)){
+            gameController.leave();
+            gameController = null;
+        }
+
         if (!Objects.isNull(server)){ // any server created is killed
             ServerBroadcast.stopServer();
             server.shutdown();
@@ -80,7 +85,6 @@
 
             gameController = new GameController(name, serverURI);
             Response serverResponse = gameController.join();
-            System.out.println("RAN HERE");
             if (serverResponse.isSuccesful()){ // always successful for host
                 lobbyMenu.setHosting(isHosting);
                 scene.setRoot(lobbyMenu);
Index: src/main/java/Server/Server.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Server;\r\n\r\nimport Game.GameCharacter.CharacterType;\r\nimport Game.Player.PlayerInfo;\r\nimport org.jspace.*;\r\n\r\nimport java.net.URI;\r\nimport java.util.Arrays;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.function.Function;\r\n\r\n\r\npublic class Server {\r\n    static boolean imposterSwitch = false;\r\n\r\n    private Map<String, Integer> playerVotes;\r\n    private Map<String, Space> playerSpaces = new HashMap<>();\r\n    private Map<String, PlayerInfo> playerInfos = new HashMap<>();\r\n\r\n    private SpaceRepository spaceRepository = new SpaceRepository();\r\n    private final Space serverSpace;\r\n    private final URI serverURI;\r\n    private ServerState state = ServerState.RUNNING_STATE;\r\n\r\n    private Thread serverThread;\r\n    private Thread meetingThread;\r\n\r\n    public Server(URI uri, Space serverSpace){\r\n        this.serverURI = uri;\r\n        this.serverSpace = serverSpace;\r\n        spaceRepository.add(\"server\", serverSpace);\r\n        spaceRepository.addGate(serverURI);\r\n    }\r\n\r\n    public void start(){\r\n        serverThread = new Thread(this::server);\r\n        serverThread.start();\r\n\r\n        System.out.println(\"Server now online:\\naddress:\" + serverURI);\r\n    }\r\n\r\n    public void shutdown(){\r\n        spaceRepository.closeGate(serverURI);\r\n\r\n        if(serverThread.isAlive() && !serverThread.isInterrupted()) serverThread.interrupt();\r\n        try{\r\n            serverThread.join();\r\n        }catch (Exception e){\r\n            System.out.println(e.getMessage());\r\n        }\r\n\r\n        System.out.println(\"Server offline.\");\r\n    }\r\n\r\n    /*\r\n    * Server loop: takes care of lobby requests\r\n    * */\r\n    private void server(){\r\n        while (true){\r\n            try {\r\n                Object[] request = serverSpace.get(new FormalField(Request.class));\r\n                switch ((Request) request[0]){\r\n                    case JOIN: {\r\n                        handleJoinRequest();\r\n                        break;\r\n                    }\r\n                    case LEAVE:\r\n                    case KICK: {\r\n                        System.out.println(\"Unsupported request!\");\r\n                        break;\r\n                    }\r\n                }\r\n            } catch (Exception e){\r\n                System.out.println(e.getMessage());\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void handleJoinRequest() {\r\n        try {\r\n            // read request\r\n            String nameRequest = (String)(serverSpace.get(new ActualField(Request.JOIN), new FormalField(String.class))[1]);\r\n\r\n            if (playerSpaces.containsKey(nameRequest)){\r\n                // player name exists already\r\n                serverSpace.put(nameRequest, Response.CONFLICT);\r\n            }\r\n            else {\r\n                // player name does not exist\r\n\r\n                // create new channel\r\n                Space privateChannel = new SequentialSpace();\r\n                playerSpaces.put(nameRequest, privateChannel);\r\n                spaceRepository.add(nameRequest, privateChannel);\r\n\r\n                new Thread(() -> handlePlayer(nameRequest)).start();\r\n\r\n                // accept request\r\n                serverSpace.put(nameRequest, Response.ACCEPTED);\r\n\r\n                initializePlayer(nameRequest);\r\n            }\r\n        } catch (InterruptedException e) {\r\n            System.out.println(e.getMessage());\r\n        }\r\n    }\r\n\r\n    private void initializePlayer(String nameRequest){\r\n        try{\r\n\r\n            PlayerInfo newPlayerInfo = new PlayerInfo(CharacterType.RED, new double[]{4900, 1500}, new double[]{0,0}, true, imposterSwitch);\r\n            imposterSwitch = !imposterSwitch;\r\n\r\n            broadcastClientUpdateExcludingSender(ServerUpdate.PLAYER_JOINED, nameRequest, newPlayerInfo);\r\n\r\n            playerSpaces.get(nameRequest).put(ServerUpdate.PLAYER_INIT, newPlayerInfo);\r\n\r\n            for (String playerName : playerInfos.keySet()){\r\n                playerSpaces.get(nameRequest).put(ServerUpdate.PLAYER_JOINED);\r\n                playerSpaces.get(nameRequest).put(ServerUpdate.PLAYER_JOINED, playerName, playerInfos.get(playerName));\r\n            }\r\n\r\n            playerInfos.put(nameRequest, newPlayerInfo);\r\n\r\n        }catch (Exception e){\r\n            System.out.println(e.getMessage());\r\n        }\r\n    }\r\n\r\n    /*\r\n    * player loop: takes case of player actions. One thread for each player\r\n    * */\r\n    private void handlePlayer(String playerName) {\r\n        while (true){\r\n            try{\r\n                Object[] updateTuple = playerSpaces.get(playerName).get(new FormalField(ClientUpdate.class));\r\n                ClientUpdate update = (ClientUpdate) updateTuple[0];\r\n\r\n                switch (update){\r\n                    case POSITION:{\r\n                        switch (state){\r\n                            case RUNNING_STATE:{\r\n                                Object[] infoTuple = playerSpaces.get(playerName).get(new ActualField(ClientUpdate.POSITION), new FormalField(Object.class), new FormalField(Object.class));\r\n\r\n                                playerInfos.get(playerName).position = (double[]) infoTuple[1];\r\n                                playerInfos.get(playerName).velocity = (double[]) infoTuple[2];\r\n\r\n                                broadcastClientUpdateExcludingSender(ServerUpdate.POSITION, playerName,\r\n                                        playerInfos.get(playerName).position,\r\n                                        playerInfos.get(playerName).velocity\r\n                                );\r\n                                break;\r\n                            }\r\n                            case MEETING_STATE:\r\n                                ignoreUpdate(update, playerName);\r\n                                break;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case KILL:{\r\n                        switch (state){\r\n                            case RUNNING_STATE:{\r\n                                Object[] infoTuple = playerSpaces.get(playerName).get(new ActualField(ClientUpdate.KILL), new FormalField(String.class) ,new FormalField(String.class));\r\n\r\n                                String killerPlayerName = (String) infoTuple[1];\r\n                                if (playerInfos.get(killerPlayerName).isImposter){\r\n                                    String killedPlayerName = (String) infoTuple[2];\r\n\r\n                                    playerInfos.get(killedPlayerName).isAlive = false;\r\n                                    broadCastClientUpdateIncludingSender(ServerUpdate.KILLED, killedPlayerName);\r\n                                }\r\n\r\n                                break;\r\n                            }\r\n                            case MEETING_STATE:{\r\n                                ignoreUpdate(update, playerName);\r\n                                break;\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MEETING:{\r\n                        switch (state){\r\n                            case RUNNING_STATE:\r\n                            {\r\n                                // change state\r\n                                state = ServerState.MEETING_STATE;\r\n\r\n                                // initialize empty votes\r\n                                playerVotes = new HashMap<>();\r\n\r\n                                // meeting logic\r\n                                meetingThread = (new Thread(() -> {\r\n                                    try {\r\n                                        // timer 1 minute\r\n                                        Thread.sleep(30*1000);\r\n                                        /*\r\n                                        * Tell the player who was eliminated: if there is a tie, it is \"NO_ELIMINATION\"\r\n                                        * */\r\n                                        state = ServerState.RUNNING_STATE;\r\n\r\n                                        String eliminatedPlayer = this.votedPlayer();\r\n                                        broadCastClientUpdateIncludingSender(ServerUpdate.MEETING_DONE, eliminatedPlayer);\r\n                                    } catch (InterruptedException e) {\r\n                                        throw new RuntimeException(e);\r\n                                    }\r\n                                }));\r\n                                meetingThread.start();\r\n\r\n                                broadCastClientUpdateIncludingSender(ServerUpdate.MEETING_START, playerName);\r\n                                break;\r\n                            }\r\n                            case MEETING_STATE: {\r\n                                break;\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case MESSAGE:{\r\n                        switch (state){\r\n                            case RUNNING_STATE:\r\n                            {\r\n                                ignoreUpdate(update, playerName);\r\n                                break;\r\n                            }\r\n                            case MEETING_STATE: {\r\n                                Object[] infoTuple = playerSpaces.get(playerName).get(new ActualField(ClientUpdate.MESSAGE), new FormalField(String.class));\r\n                                broadCastClientUpdateIncludingSender(ServerUpdate.MESSAGE, playerName, infoTuple[1]);\r\n                                break;\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                    case VOTE:{\r\n                        switch (state){\r\n                            case MEETING_STATE: {\r\n                                Object[] infoTuple = playerSpaces.get(playerName).get(new ActualField(ClientUpdate.VOTE), new FormalField(String.class));\r\n                                String voted = (String) infoTuple[1];\r\n\r\n                                // add 1 to the votes received from voter\r\n                                playerVotes.put(voted, playerVotes.getOrDefault(voted, 0) + 1);;\r\n\r\n                                broadCastClientUpdateIncludingSender(ServerUpdate.VOTE, playerName, voted);\r\n                                break;\r\n                            }\r\n                            case RUNNING_STATE: {\r\n                                ignoreUpdate(update, playerName);\r\n                                break;\r\n                            }\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }catch (Exception e){\r\n                System.out.println(e.getMessage());\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private String votedPlayer() {\r\n        String winner = null;\r\n        int maxVotes = -1;\r\n        boolean tie = true;\r\n\r\n        for (Map.Entry<String, Integer> entry : playerVotes.entrySet()) {\r\n            int voteCount = entry.getValue();\r\n\r\n            if (voteCount > maxVotes) {\r\n                // Found a strictly bigger vote count, update winner\r\n                maxVotes = voteCount;\r\n                winner = entry.getKey();\r\n                tie = false; // reset tie flag\r\n            } else if (voteCount == maxVotes) {\r\n                // Found another with the same max votes -> it's a tie\r\n                tie = true;\r\n            }\r\n        }\r\n\r\n        // If tie is true, return null; otherwise return the winner's name.\r\n        return tie ? \"NO_ELIMINATION\" : winner;\r\n    }\r\n\r\n    /*\r\n    * broadcasts an update from the server to every player.\r\n    * */\r\n    private void broadcastClientUpdateExcludingSender(ServerUpdate updateCode, String playerName, Object... toBroadcast){\r\n        broadcastClientUpdateGivenCondition((String s) -> !s.equals(playerName), updateCode, playerName, toBroadcast);\r\n    }\r\n\r\n    private void broadCastClientUpdateIncludingSender(ServerUpdate updateCode, String playerName, Object... toBroadcast){\r\n        broadcastClientUpdateGivenCondition(((String s) -> true), updateCode, playerName, toBroadcast);\r\n    }\r\n    /*\r\n    * cleans up after an update that is out of context\r\n    * */\r\n    private void ignoreUpdate(ClientUpdate update, String playerName){\r\n        try\r\n        {\r\n            switch (update){\r\n                case POSITION: {\r\n                    playerSpaces.get(playerName).get(new ActualField(ClientUpdate.POSITION),new FormalField(Object.class), new FormalField(Object.class));\r\n                    break;\r\n                }\r\n                case VOTE: {\r\n                    playerSpaces.get(playerName).get(new ActualField(ClientUpdate.VOTE), new FormalField(String.class));\r\n                    break;\r\n                }\r\n                case MEETING:{\r\n                    break;\r\n                }\r\n                case MESSAGE:{\r\n                    playerSpaces.get(playerName).get(new ActualField(ClientUpdate.MESSAGE), new FormalField(String.class), new FormalField(String.class));\r\n                }\r\n                case KILL:{\r\n                    break;\r\n                }\r\n\r\n            }\r\n        } catch (Exception e){\r\n            System.out.println(Arrays.toString(e.getStackTrace()));\r\n        }\r\n    }\r\n\r\n    private void broadcastClientUpdateGivenCondition(Function<String, Boolean> condition, ServerUpdate updateCode, String playerName, Object... toBroadcast){\r\n        try {\r\n            switch (updateCode){\r\n                case POSITION: { // two field cases\r\n                    for(String name : playerSpaces.keySet()){\r\n                        if (condition.apply(name)){\r\n                            playerSpaces.get(name).put(updateCode);\r\n                            playerSpaces.get(name).put(updateCode, playerName, toBroadcast[0], toBroadcast[1]);\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case VOTE:\r\n                case MESSAGE:\r\n                case PLAYER_JOINED: { // one field cases\r\n                    for(String name : playerSpaces.keySet()){\r\n                        if (condition.apply(name)){\r\n                        playerSpaces.get(name).put(updateCode);\r\n                        playerSpaces.get(name).put(updateCode, playerName, toBroadcast[0]);\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case KILLED: // playerName is the name to kill\r\n                case PLAYER_LEFT: // zero field cases\r\n                case MEETING_START: // meeting is called by one player (playerName field)\r\n                case MEETING_DONE: { // meeting is ended by server. playerName is the player to kick out\r\n                    for(String name : playerSpaces.keySet()){\r\n                        if (condition.apply(name)){\r\n                        playerSpaces.get(name).put(updateCode);\r\n                        playerSpaces.get(name).put(updateCode, playerName);\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        } catch (Exception e){\r\n            System.out.println(Arrays.toString(e.getStackTrace()));\r\n        }\r\n    }\r\n\r\n    public void startGame() {\r\n        for (Space playerSpace : playerSpaces.values()){\r\n            System.out.println(1);\r\n            try {\r\n                playerSpace.put(ServerUpdate.GAME_START);\r\n            } catch (InterruptedException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        };\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/Server/Server.java b/src/main/java/Server/Server.java
--- a/src/main/java/Server/Server.java	(revision 78b6d1e85c33d63aaff86e6bb72ba2c4f6fc9865)
+++ b/src/main/java/Server/Server.java	(date 1737373021637)
@@ -16,6 +16,7 @@
 
     private Map<String, Integer> playerVotes;
     private Map<String, Space> playerSpaces = new HashMap<>();
+    private Map<String, Thread> playerThreads = new HashMap<>();
     private Map<String, PlayerInfo> playerInfos = new HashMap<>();
 
     private SpaceRepository spaceRepository = new SpaceRepository();
@@ -65,7 +66,10 @@
                         handleJoinRequest();
                         break;
                     }
-                    case LEAVE:
+                    case LEAVE: {
+                        handleLeaveRequest();
+                        break;
+                    }
                     case KICK: {
                         System.out.println("Unsupported request!");
                         break;
@@ -95,7 +99,9 @@
                 playerSpaces.put(nameRequest, privateChannel);
                 spaceRepository.add(nameRequest, privateChannel);
 
-                new Thread(() -> handlePlayer(nameRequest)).start();
+                Thread playerThread = new Thread(() -> handlePlayer(nameRequest));
+                playerThreads.put(nameRequest, playerThread);
+                playerThread.start();
 
                 // accept request
                 serverSpace.put(nameRequest, Response.ACCEPTED);
@@ -107,6 +113,22 @@
         }
     }
 
+    private void handleLeaveRequest(){
+        try {
+            String name = (String)(serverSpace.get(new ActualField(Request.LEAVE), new FormalField(String.class))[1]);
+            broadcastClientUpdateExcludingSender(ServerUpdate.PLAYER_LEFT, name);
+
+            playerThreads.get(name).interrupt();
+            playerThreads.remove(name);
+
+            playerSpaces.remove(name);
+            playerInfos.remove(name);
+
+        }catch (Exception e){
+            System.out.println("error in handle leave");
+        }
+    }
+
     private void initializePlayer(String nameRequest){
         try{
 
